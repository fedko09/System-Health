param(
    [switch]$NoGui,
    [switch]$Minimal   # For -NoGui: skip heavy stuff like full software list
)

<# 
.SYNOPSIS
  System Health Snapshot GUI / CLI for Windows 10/11

.DESCRIPTION
  Shows:
    - System specs
    - Disk health
    - Running services
    - Installed software
    - Security status
    - Performance snapshot
    - Event log summary
    - Network health

  Features:
    - WPF GUI with search + per-tab filters
    - Risk coloring for disks/services
    - Per-tab summaries (Disks/Services/Software)
    - Export current tab to CSV
    - Generate HTML snapshot report (with summaries + findings + network)
    - Security Findings tab (severity + recommendations)
    - Network tab (adapters + connectivity tests)
    - Right-click service start/stop/restart
    - Technician summary copy button
    - CLI mode with -NoGui (writes HTML report and exits)
#>

Add-Type -AssemblyName PresentationCore, PresentationFramework, WindowsBase

# -----------------------------
# Helpers
# -----------------------------

function Test-IsAdmin {
    $id = [Security.Principal.WindowsIdentity]::GetCurrent()
    $p  = New-Object Security.Principal.WindowsPrincipal($id)
    return $p.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
}

function Enable-GridSorting {
    param(
        [System.Windows.Controls.DataGrid]$Grid
    )
    if (-not $Grid) { return }

    # Ensure SortMemberPath is set
    $Grid.Add_AutoGeneratedColumns({
        param($sender,$eventArgs)
        foreach ($col in $sender.Columns) {
            if (-not $col.SortMemberPath -or $col.SortMemberPath -eq '') {
                $col.SortMemberPath = $col.Header.ToString()
            }
        }
    })

    # Manual sort so it cooperates with our filtered datasets
    $Grid.Add_Sorting({
        param($sender,$e)

        $header = $mainTabs.SelectedItem.Header.ToString()
        if (-not $script:tabMap.ContainsKey($header)) { return }

        $tabInfo = $script:tabMap[$header]
        $key     = $tabInfo.Key

        $allData = $script:dataSets[$key]
        if (-not $allData) { return }

        $propName = $e.Column.SortMemberPath
        if (-not $propName) { return }

        # Decide direction
        $currentDir = $e.Column.SortDirection
        if ($currentDir -eq [System.ComponentModel.ListSortDirection]::Ascending) {
            $newDir = [System.ComponentModel.ListSortDirection]::Descending
        }
        else {
            $newDir = [System.ComponentModel.ListSortDirection]::Ascending
        }

        if ($newDir -eq [System.ComponentModel.ListSortDirection]::Ascending) {
            $sorted = $allData | Sort-Object $propName
        }
        else {
            $sorted = $allData | Sort-Object $propName -Descending
        }

        $script:dataSets[$key] = @($sorted)
        $e.Column.SortDirection = $newDir
        $e.Handled = $true

        Refresh-CurrentTab
    })
}

# -----------------------------
# Data collection functions
# -----------------------------

function Get-SystemSpecs {
    try {
        $os  = Get-CimInstance Win32_OperatingSystem
        $cs  = Get-CimInstance Win32_ComputerSystem
        $cpu = Get-CimInstance Win32_Processor | Select-Object -First 1
        $mem = Get-CimInstance Win32_PhysicalMemory

        $totalRamGB = [math]::Round(($mem | Measure-Object -Property Capacity -Sum).Sum / 1GB, 2)
        $uptime = (Get-Date) - $os.LastBootUpTime

        [PSCustomObject]@{
            ComputerName   = $env:COMPUTERNAME
            OS             = "$($os.Caption) $($os.OSArchitecture)"
            OS_Version     = $os.Version
            Build          = $os.BuildNumber
            InstallDate    = $os.InstallDate
            Uptime_Days    = [math]::Round($uptime.TotalDays, 2)
            Manufacturer   = $cs.Manufacturer
            Model          = $cs.Model
            CPU            = $cpu.Name
            CPU_Cores      = $cpu.NumberOfCores
            CPU_Logical    = $cpu.NumberOfLogicalProcessors
            RAM_GB         = $totalRamGB
            Domain         = $cs.Domain
            LoggedOnUser   = $env:USERNAME
        }
    }
    catch {
        Write-Warning "Failed to get system specs: $_"
        @()
    }
}

function Get-DiskHealth {
    $results = @()

    try {
        if (Get-Command Get-PhysicalDisk -ErrorAction SilentlyContinue) {
            $physical = Get-PhysicalDisk
            foreach ($disk in $physical) {
                $results += [PSCustomObject]@{
                    FriendlyName      = $disk.FriendlyName
                    SerialNumber      = $disk.SerialNumber
                    MediaType         = $disk.MediaType
                    HealthStatus      = $disk.HealthStatus
                    OperationalStatus = ($disk.OperationalStatus -join ', ')
                    Size_GB           = [math]::Round($disk.Size / 1GB, 2)
                    Free_GB           = $null
                    Free_Percent      = $null
                    RiskLevel         = $null
                }
            }
        }
        else {
            $wmiDisks = Get-CimInstance Win32_DiskDrive
            foreach ($disk in $wmiDisks) {
                $results += [PSCustomObject]@{
                    FriendlyName      = $disk.Model
                    SerialNumber      = $disk.SerialNumber
                    MediaType         = $disk.MediaType
                    HealthStatus      = "Unknown (legacy WMI)"
                    OperationalStatus = $disk.Status
                    Size_GB           = [math]::Round($disk.Size / 1GB, 2)
                    Free_GB           = $null
                    Free_Percent      = $null
                    RiskLevel         = $null
                }
            }
        }
    }
    catch {
        Write-Warning "Failed to get physical disk info: $_"
    }

    # Logical volumes with free space and risk level
    try {
        $volumes = Get-CimInstance Win32_LogicalDisk -Filter "DriveType=3"
        foreach ($v in $volumes) {
            $freeGB = [math]::Round($v.FreeSpace / 1GB, 2)
            $sizeGB = [math]::Round($v.Size / 1GB, 2)
            $freePct = if ($v.Size -gt 0) { [math]::Round(($v.FreeSpace / $v.Size) * 100, 1) } else { $null }

            $risk =
                if ($freePct -lt 10) { "Critical" }
                elseif ($freePct -lt 20) { "Warning" }
                else { "OK" }

            $results += [PSCustomObject]@{
                FriendlyName      = "Volume $($v.DeviceID)"
                SerialNumber      = ""
                MediaType         = "LogicalDisk"
                HealthStatus      = "N/A"
                OperationalStatus = "N/A"
                Size_GB           = $sizeGB
                Free_GB           = $freeGB
                Free_Percent      = $freePct
                RiskLevel         = $risk
            }
        }
    }
    catch {
        Write-Warning "Failed to get logical disk info: $_"
    }

    $results
}

function Get-RunningServices {
    try {
        Get-Service | Sort-Object Status, DisplayName | ForEach-Object {
            $problem = ($_.Status -eq 'Stopped' -and $_.StartType -eq 'Automatic')
            [PSCustomObject]@{
                Name        = $_.Name
                DisplayName = $_.DisplayName
                Status      = $_.Status
                StartType   = $_.StartType
                ServiceType = $_.ServiceType
                Problem     = $problem
            }
        }
    }
    catch {
        Write-Warning "Failed to get services: $_"
        @()
    }
}

function Get-InstalledSoftware {
    $paths = @(
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*",
        "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
    )
    $apps = @()

    foreach ($path in $paths) {
        try {
            $items = Get-ItemProperty -Path $path -ErrorAction SilentlyContinue |
                Where-Object { $_.DisplayName -and $_.DisplayName.Trim() -ne "" }

            foreach ($item in $items) {
                # InstallDate often is yyyymmdd or empty
                $installDateRaw = $item.InstallDate
                $installDateParsed = $null
                if ($installDateRaw -and $installDateRaw.ToString().Length -eq 8) {
                    $installDateParsed = [datetime]::ParseExact($installDateRaw.ToString(), 'yyyyMMdd', $null)
                }

                $apps += [PSCustomObject]@{
                    Name            = $item.DisplayName
                    Version         = $item.DisplayVersion
                    Publisher       = $item.Publisher
                    InstallDateRaw  = $installDateRaw
                    InstallDate     = $installDateParsed
                    InstallSource   = $item.InstallSource
                    UninstallString = $item.UninstallString
                    RegistryPath    = $path
                }
            }
        }
        catch {
            Write-Verbose "Failed reading $path : $_"
        }
    }

    $apps | Sort-Object Name
}

function Get-SecurityStatus {
    $result = [PSCustomObject]@{
        AV_RealTimeProtection  = "Unknown"
        AV_SignatureOutOfDate  = "Unknown"
        Firewall_Domain        = "Unknown"
        Firewall_Private       = "Unknown"
        Firewall_Public        = "Unknown"
        BitLocker_Protection   = "Unknown"
        UAC_Enabled            = "Unknown"
        RDP_Enabled            = "Unknown"
        RDP_NLA_Required       = "Unknown"
        LocalAdmins_Count      = "Unknown"
        Guest_Enabled          = "Unknown"
    }

    try {
        if (Get-Command Get-MpComputerStatus -ErrorAction SilentlyContinue) {
            $mp = Get-MpComputerStatus
            $result.AV_RealTimeProtection = $mp.RealTimeProtectionEnabled
            $result.AV_SignatureOutOfDate = ($mp.AntispywareSignatureAge -gt 1 -or $mp.AntivirusSignatureAge -gt 1)
        }
        else {
            $result.AV_RealTimeProtection = "Get-MpComputerStatus not available"
        }
    }
    catch {
        $result.AV_RealTimeProtection = "Error: $_"
    }

    try {
        if (Get-Command Get-NetFirewallProfile -ErrorAction SilentlyContinue) {
            $profiles = Get-NetFirewallProfile
            foreach ($p in $profiles) {
                switch ($p.Name) {
                    'Domain'  { $result.Firewall_Domain  = $p.Enabled }
                    'Private' { $result.Firewall_Private = $p.Enabled }
                    'Public'  { $result.Firewall_Public  = $p.Enabled }
                }
            }
        }
        else {
            $result.Firewall_Domain  = "cmdlet not available"
            $result.Firewall_Private = "cmdlet not available"
            $result.Firewall_Public  = "cmdlet not available"
        }
    }
    catch {
        $result.Firewall_Domain = "Error: $_"
    }

    try {
        if (Get-Command Get-BitLockerVolume -ErrorAction SilentlyContinue) {
            $bl = Get-BitLockerVolume | Select-Object MountPoint, VolumeStatus, ProtectionStatus
            $result.BitLocker_Protection = ($bl | ForEach-Object {
                "$($_.MountPoint): $($_.ProtectionStatus)"
            }) -join "; "
        }
        else {
            $result.BitLocker_Protection = "Get-BitLockerVolume not available"
        }
    }
    catch {
        $result.BitLocker_Protection = "Error: $_"
    }

    # UAC
    try {
        $uac = Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' -ErrorAction Stop
        $result.UAC_Enabled = [bool]$uac.EnableLUA
    }
    catch {
        $result.UAC_Enabled = "Error: $_"
    }

    # RDP enabled?
    try {
        $ts = Get-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server' -ErrorAction Stop
        $result.RDP_Enabled = ($ts.fDenyTSConnections -eq 0)
    }
    catch {
        $result.RDP_Enabled = "Error: $_"
    }

    # RDP NLA required?
    try {
        $tcp = Get-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -ErrorAction Stop
        $result.RDP_NLA_Required = ($tcp.UserAuthentication -eq 1)
    }
    catch {
        $result.RDP_NLA_Required = "Unknown"
    }

    # Local Administrators count
    try {
        if (Get-Command Get-LocalGroupMember -ErrorAction SilentlyContinue) {
            $admins = Get-LocalGroupMember -Group 'Administrators' -ErrorAction SilentlyContinue
            $result.LocalAdmins_Count = @($admins).Count
        }
        else {
            $result.LocalAdmins_Count = "Unknown"
        }
    }
    catch {
        $result.LocalAdmins_Count = "Error: $_"
    }

    # Guest account enabled?
    try {
        if (Get-Command Get-LocalUser -ErrorAction SilentlyContinue) {
            $guest = Get-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue
            if ($guest) {
                $result.Guest_Enabled = $guest.Enabled
            }
            else {
                $result.Guest_Enabled = "Unknown"
            }
        }
        else {
            $result.Guest_Enabled = "Unknown"
        }
    }
    catch {
        $result.Guest_Enabled = "Error: $_"
    }

    $result
}

function Get-PerformanceSnapshot {
    $summary = $null
    $topProcs = @()

    try {
        $cpuSample = Get-Counter '\Processor(_Total)\% Processor Time'
        $cpu = [math]::Round($cpuSample.CounterSamples[0].CookedValue, 1)

        $os = Get-CimInstance Win32_OperatingSystem
        $totalGB = [math]::Round($os.TotalVisibleMemorySize / 1MB, 2)
        $freeGB  = [math]::Round($os.FreePhysicalMemory / 1MB, 2)
        $usedGB  = $totalGB - $freeGB
        $memPct  = if ($totalGB -gt 0) { [math]::Round(($usedGB / $totalGB) * 100, 1) } else { 0 }

        $summary = [pscustomobject]@{
            CPU_Usage_Percent = $cpu
            RAM_Used_GB       = $usedGB
            RAM_Total_GB      = $totalGB
            RAM_Used_Percent  = $memPct
        }
    }
    catch {
        $summary = [pscustomobject]@{
            CPU_Usage_Percent = "Error"
            RAM_Used_GB       = "Error"
            RAM_Total_GB      = "Error"
            RAM_Used_Percent  = "Error"
        }
    }

    try {
        $topProcs = Get-Process | Sort-Object CPU -Descending | Select-Object -First 15 `
            @{n='Name';e={$_.Name}},
            @{n='Id';e={$_.Id}},
            @{n='CPU_Time_s';e={[math]::Round($_.CPU,1)}},
            @{n='WorkingSet_MB';e={[math]::Round($_.WorkingSet64/1MB,1)}},
            @{n='PagedMem_MB';e={[math]::Round($_.PagedMemorySize64/1MB,1)}}
    }
    catch {
        $topProcs = @()
    }

    @{
        Summary      = $summary
        TopProcesses = $topProcs
    }
}

function Get-EventLogSummary {
    $rows = @()
    try {
        $since = (Get-Date).AddHours(-24)
        $logs  = @('System','Application')
        $events = Get-WinEvent -FilterHashtable @{LogName=$logs; StartTime=$since} -ErrorAction SilentlyContinue

        $groups = $events | Group-Object LogName, LevelDisplayName
        foreach ($g in $groups) {
            $first = $g.Group | Select-Object -First 1
            $topSource = ($g.Group |
                Group-Object ProviderName |
                Sort-Object Count -Descending |
                Select-Object -First 1).Name

            $rows += [pscustomobject]@{
                LogName   = $first.LogName
                Level     = $first.LevelDisplayName
                Count     = $g.Count
                TopSource = $topSource
            }
        }
    }
    catch {
        Write-Warning "Failed to read event logs: $_"
    }

    $rows | Sort-Object LogName, Level
}

function Get-UpdateStatus {
    $lastHotfix = $null
    try {
        $lastHotfix = Get-CimInstance Win32_QuickFixEngineering |
            Sort-Object InstalledOn -Descending |
            Select-Object -First 1
    }
    catch {
        $lastHotfix = $null
    }

    $pending = $false
    try {
        if (Test-Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending') {
            $pending = $true
        }
        elseif (Test-Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired') {
            $pending = $true
        }
    }
    catch {
        $pending = $false
    }

    [pscustomobject]@{
        LastHotfixId   = $lastHotfix.HotFixID
        LastHotfixDate = $lastHotfix.InstalledOn
        PendingReboot  = $pending
    }
}

function Get-NetworkInfoAndTests {
    $adapters = @()
    $tests    = @()

    try {
        if (Get-Command Get-NetIPConfiguration -ErrorAction SilentlyContinue) {
            $cfgs = Get-NetIPConfiguration | Where-Object { $_.IPv4Address -or $_.IPv6Address }
            foreach ($c in $cfgs) {
                $ipv4 = $null
                if ($c.IPv4Address) {
                    $ipv4 = $c.IPv4Address[0].IPv4Address
                }
                $gw  = $null
                if ($c.IPv4DefaultGateway) {
                    $gw = $c.IPv4DefaultGateway.NextHop
                }
                $dns = $null
                if ($c.DnsServer -and $c.DnsServer.ServerAddresses) {
                    $dns = ($c.DnsServer.ServerAddresses -join ', ')
                }

                $adapters += [pscustomobject]@{
                    InterfaceAlias = $c.InterfaceAlias
                    Description    = $c.InterfaceDescription
                    IPv4Address    = $ipv4
                    DefaultGateway = $gw
                    DnsServers     = $dns
                    Dhcp           = $c.Dhcp
                }
            }
        }
        else {
            $wmi = Get-CimInstance Win32_NetworkAdapterConfiguration -Filter "IPEnabled=TRUE"
            foreach ($n in $wmi) {
                $adapters += [pscustomobject]@{
                    InterfaceAlias = $n.Description
                    Description    = $n.Description
                    IPv4Address    = ($n.IPAddress | Where-Object { $_ -match '\.' } | Select-Object -First 1)
                    DefaultGateway = ($n.DefaultIPGateway | Select-Object -First 1)
                    DnsServers     = ($n.DNSServerSearchOrder -join ', ')
                    Dhcp           = $n.DHCPEnabled
                }
            }
        }
    }
    catch {
        Write-Warning "Failed to get network adapter info: $_"
    }

    # Connectivity tests
    $defaultGw = ($adapters | Where-Object { $_.DefaultGateway } | Select-Object -First 1).DefaultGateway
    if ($defaultGw) {
        try {
            $ok = Test-Connection -ComputerName $defaultGw -Count 1 -Quiet -ErrorAction SilentlyContinue
            $resultValue = if ($ok) { "OK" } else { "Fail" }

            $tests += [pscustomobject]@{
                Test    = "Ping default gateway ($defaultGw)"
                Result  = $resultValue
                Details = ""
            }
        }
        catch {
            $tests += [pscustomobject]@{
                Test    = "Ping default gateway ($defaultGw)"
                Result  = "Error"
                Details = "$_"
            }
        }
    }
    else {
        $tests += [pscustomobject]@{
            Test    = "Default gateway"
            Result  = "Missing"
            Details = "No default gateway detected on active adapters."
        }
    }

    try {
        $ok = Test-Connection -ComputerName "8.8.8.8" -Count 1 -Quiet -ErrorAction SilentlyContinue
        $resultValue = if ($ok) { "OK" } else { "Fail" }

        $tests += [pscustomobject]@{
            Test    = "Ping 8.8.8.8"
            Result  = $resultValue
            Details = ""
        }
    }
    catch {
        $tests += [pscustomobject]@{
            Test    = "Ping 8.8.8.8"
            Result  = "Error"
            Details = "$_"
        }
    }

    try {
        if (Get-Command Resolve-DnsName -ErrorAction SilentlyContinue) {
            $ok = $false
            try {
                $null = Resolve-DnsName -Name "microsoft.com" -ErrorAction Stop
                $ok = $true
            }
            catch {
                $ok = $false
            }

            $resultValue = if ($ok) { "OK" } else { "Fail" }

            $tests += [pscustomobject]@{
                Test    = "DNS resolve microsoft.com"
                Result  = $resultValue
                Details = ""
            }
        }
        else {
            $tests += [pscustomobject]@{
                Test    = "DNS resolve microsoft.com"
                Result  = "Unknown"
                Details = "Resolve-DnsName not available."
            }
        }
    }
    catch {
        $tests += [pscustomobject]@{
            Test    = "DNS resolve microsoft.com"
            Result  = "Error"
            Details = "$_"
        }
    }

    @{
        Adapters = $adapters
        Tests    = $tests
    }
}

function ConvertTo-NameValueTable {
    param(
        [Parameter(Mandatory=$true)]
        $Object
    )

    if (-not $Object) { return @() }

    $rows = @()
    foreach ($p in $Object.PSObject.Properties) {
        $rows += [pscustomobject]@{
            Name  = $p.Name
            Value = $p.Value
        }
    }
    $rows
}

# Summary stats helpers

function Get-DiskSummaryStats {
    param([Parameter(Mandatory=$true)]$Disks)

    $logical = @($Disks | Where-Object { $_.Free_Percent -ne $null })
    $total = $logical.Count
    $critical = @($logical | Where-Object { $_.Free_Percent -lt 10 }).Count
    $warning  = @($logical | Where-Object { $_.Free_Percent -ge 10 -and $_.Free_Percent -lt 20 }).Count

    [pscustomobject]@{
        LogicalVolumes          = $total
        CriticalBelow10Percent  = $critical
        WarningBelow20Percent   = $warning
    }
}

function Get-ServiceSummaryStats {
    param([Parameter(Mandatory=$true)]$Services)

    $total   = @($Services).Count
    $running = @($Services | Where-Object { $_.Status -eq 'Running' }).Count
    $stoppedAuto = @($Services | Where-Object { $_.Problem -eq $true }).Count

    [pscustomobject]@{
        TotalServices       = $total
        Running             = $running
        StoppedAutomatic    = $stoppedAuto
    }
}

function Get-SoftwareSummaryStats {
    param([Parameter(Mandatory=$true)]$Software)

    $total = @($Software).Count
    $cut   = (Get-Date).AddDays(-30)
    $recent = @($Software | Where-Object { $_.InstallDate -and $_.InstallDate -ge $cut }).Count

    [pscustomobject]@{
        TotalInstalled        = $total
        InstalledLast30Days   = $recent
    }
}

function Get-SecurityFindings {
    param(
        $Security,
        $UpdateStatus,
        $NetworkTests
    )

    $findings = @()

    function AddFinding($Severity,$Area,$Finding,$Recommendation) {
        $findings += [pscustomobject]@{
            Severity       = $Severity
            Area           = $Area
            Finding        = $Finding
            Recommendation = $Recommendation
        }
    }

    if ($Security) {
        if ($Security.AV_RealTimeProtection -eq $false) {
            AddFinding "High" "Antivirus" "Real-time protection appears to be disabled." "Re-enable Defender or third-party AV real-time protection."
        }
        if ($Security.AV_SignatureOutOfDate -eq $true) {
            AddFinding "Medium" "Antivirus" "AV signatures appear out of date." "Run AV update / Windows Update to refresh signatures."
        }
        if ($Security.Firewall_Domain -eq $false -or $Security.Firewall_Private -eq $false -or $Security.Firewall_Public -eq $false) {
            AddFinding "High" "Firewall" "One or more firewall profiles are disabled." "Re-enable Windows Firewall or validated third-party firewall."
        }
        if ($Security.UAC_Enabled -eq $false) {
            AddFinding "Medium" "UAC" "UAC is disabled." "Re-enable User Account Control to reduce risk of silent elevation."
        }

        if ($Security.RDP_Enabled -eq $true) {
            AddFinding "Medium" "RDP" "Remote Desktop is enabled." "Ensure RDP is needed and limited by firewall/VPN."
            if ($Security.RDP_NLA_Required -ne $true) {
                AddFinding "High" "RDP" "RDP does not require Network Level Authentication (NLA)." "Enable NLA for RDP sessions."
            }
        }

        if ($Security.LocalAdmins_Count -as [int] -gt 3) {
            AddFinding "Medium" "Accounts" "Local Administrators group has $($Security.LocalAdmins_Count) members." "Review and reduce local admin membership."
        }

        if ($Security.Guest_Enabled -eq $true) {
            AddFinding "High" "Accounts" "Guest account is enabled." "Disable the Guest account unless absolutely required."
        }
    }

    if ($UpdateStatus) {
        if ($UpdateStatus.PendingReboot -eq $true) {
            AddFinding "Medium" "Updates" "System has a pending reboot from updates." "Schedule and complete a reboot to finalize updates."
        }
    }

    if ($NetworkTests) {
        $gwTest   = $NetworkTests | Where-Object { $_.Test -like "Ping default gateway*" } | Select-Object -First 1
        $pingTest = $NetworkTests | Where-Object { $_.Test -eq "Ping 8.8.8.8" } | Select-Object -First 1
        $dnsTest  = $NetworkTests | Where-Object { $_.Test -like "DNS resolve*" } | Select-Object -First 1

        if ($gwTest -and $gwTest.Result -ne "OK") {
            AddFinding "High" "Network" "Cannot reach default gateway." "Check cabling, Wi-Fi, NIC status, and router/gateway availability."
        }
        if ($pingTest -and $pingTest.Result -ne "OK") {
            AddFinding "High" "Network" "Cannot reach 8.8.8.8 (public internet)." "Check upstream gateway, ISP connectivity, and firewall rules."
        }
        if ($dnsTest -and $dnsTest.Result -ne "OK" -and $dnsTest.Result -ne "Unknown") {
            AddFinding "Medium" "DNS" "DNS resolution for microsoft.com failed." "Check DNS server settings and DNS service availability."
        }
    }

    if (-not $findings) {
        AddFinding "Info" "Overall" "No major issues detected by basic checks." "Review detailed tabs (Events, Disks, Services) for deeper diagnostics."
    }

    $findings
}
function Get-TechnicianSummary {
    param(
        $Specs,
        $DiskStats,
        $ServiceStats,
        $SoftwareStats,
        $Security,
        $UpdateStatus,
        $NetworkTests
    )

    $lines = @()

    if ($Specs) {
        $lines += "System: $($Specs.ComputerName) | OS: $($Specs.OS) | Uptime: $($Specs.Uptime_Days) days"
    }

    if ($DiskStats) {
        $lines += "Disks: Logical=$($DiskStats.LogicalVolumes), Critical<10%=$($DiskStats.CriticalBelow10Percent), Warning<20%=$($DiskStats.WarningBelow20Percent)"
    }

    if ($ServiceStats) {
        $lines += "Services: Total=$($ServiceStats.TotalServices), Running=$($ServiceStats.Running), StoppedAuto=$($ServiceStats.StoppedAutomatic)"
    }

    if ($SoftwareStats) {
        $lines += "Software: Total=$($SoftwareStats.TotalInstalled), InstalledLast30Days=$($SoftwareStats.InstalledLast30Days)"
    }

    if ($Security) {
        $secFlags = @()
        if ($Security.AV_RealTimeProtection -eq $false) { $secFlags += "AV real-time OFF" }
        if ($Security.AV_SignatureOutOfDate -eq $true) { $secFlags += "AV signatures STALE" }
        if ($Security.Firewall_Domain -eq $false -or $Security.Firewall_Private -eq $false -or $Security.Firewall_Public -eq $false) { $secFlags += "Firewall profile OFF" }
        if ($Security.UAC_Enabled -eq $false) { $secFlags += "UAC OFF" }

        if ($secFlags.Count -gt 0) {
            $lines += "Security flags: " + ($secFlags -join "; ")
        }
        else {
            $lines += "Security flags: none detected by basic checks."
        }
    }

    if ($UpdateStatus) {
        $lines += "Updates: LastHotfix=$($UpdateStatus.LastHotfixId) on $($UpdateStatus.LastHotfixDate); PendingReboot=$($UpdateStatus.PendingReboot)"
    }

    if ($NetworkTests) {
        $netSummary = $NetworkTests | ForEach-Object { "$($_.Test): $($_.Result)" }
        $lines += "Network tests: " + ($netSummary -join " | ")
    }

    $lines -join "`r`n"
}

function Generate-HTMLSnapshot {
    param(
        $Specs,
        $Disks,
        $Security,
        $PerfSummary,
        $Events,
        $Services,
        $Software,
        $NetworkTests,
        $Findings,
        [switch]$Minimal
    )

    $specTable  = ConvertTo-NameValueTable -Object $Specs
    $secTable   = ConvertTo-NameValueTable -Object $Security
    $perfTable  = ConvertTo-NameValueTable -Object $PerfSummary

    $diskSummaryObj     = if ($Disks)    { Get-DiskSummaryStats    -Disks $Disks }         else { $null }
    $serviceSummaryObj  = if ($Services) { Get-ServiceSummaryStats -Services $Services }   else { $null }
    $softwareSummaryObj = if ($Software) { Get-SoftwareSummaryStats -Software $Software } else { $null }

    $bodyParts = @()

    $bodyParts += ($specTable  | ConvertTo-Html -As Table -PreContent '<h2>Specs</h2>' -Fragment)
    $bodyParts += ($secTable   | ConvertTo-Html -As Table -PreContent '<h2>Security</h2>' -Fragment)
    $bodyParts += ($perfTable  | ConvertTo-Html -As Table -PreContent '<h2>Performance</h2>' -Fragment)

    if ($diskSummaryObj) {
        $bodyParts += ($diskSummaryObj | ConvertTo-Html -As Table -PreContent '<h2>Disk Summary</h2>' -Fragment)
    }
    $bodyParts += ($Disks      | ConvertTo-Html -As Table -PreContent '<h2>Disks</h2>' -Fragment)

    if ($serviceSummaryObj -and -not $Minimal) {
        $bodyParts += ($serviceSummaryObj | ConvertTo-Html -As Table -PreContent '<h2>Service Summary</h2>' -Fragment)
    }

    if ($softwareSummaryObj -and -not $Minimal) {
        $bodyParts += ($softwareSummaryObj | ConvertTo-Html -As Table -PreContent '<h2>Software Summary</h2>' -Fragment)
    }

    if ($NetworkTests) {
        $bodyParts += ($NetworkTests | ConvertTo-Html -As Table -PreContent '<h2>Network Tests</h2>' -Fragment)
    }

    if ($Findings) {
        $bodyParts += ($Findings | ConvertTo-Html -As Table -PreContent '<h2>Security Findings</h2>' -Fragment)
    }

    $bodyParts += ($Events     | ConvertTo-Html -As Table -PreContent '<h2>Event Log Summary (Last 24h)</h2>' -Fragment)

    if (-not $Minimal) {
        if ($Services) {
            $bodyParts += ($Services | ConvertTo-Html -As Table -PreContent '<h2>Services</h2>' -Fragment)
        }
        if ($Software) {
            $bodyParts += ($Software | Select-Object Name, Version, Publisher, InstallDate |
                           ConvertTo-Html -As Table -PreContent '<h2>Installed Software</h2>' -Fragment)
        }
    }

    $head = @'
<meta charset="utf-8" />
<style>
body { font-family:"Segoe UI",sans-serif; font-size:12px; }
h1 { font-size:20px; }
h2 { margin-top:20px; border-bottom:1px solid #ccc; padding-bottom:3px;}
table { border-collapse:collapse; margin-top:8px; }
th, td { border:1px solid #ccc; padding:4px 6px; }
th { background:#eee; cursor:pointer; }
</style>
'@

    $title = "System Health Snapshot - $($Specs.ComputerName)"
    $headerHtml = "<h1>$title</h1><p>Generated: $(Get-Date)</p>"

    $html = ConvertTo-Html -Title $title -Head $head -Body ($headerHtml + ($bodyParts -join "`n"))
    $outPath = Join-Path ([Environment]::GetFolderPath('Desktop')) (
        "SystemSnapshot-{0}-{1}.html" -f $Specs.ComputerName, (Get-Date -Format 'yyyyMMdd_HHmmss')
    )

    $html | Out-File -FilePath $outPath -Encoding UTF8
    return $outPath
}

# -----------------------------
# If running in CLI -NoGui mode
# -----------------------------

if ($NoGui) {
    $specs   = Get-SystemSpecs
    $sec     = Get-SecurityStatus
    $disks   = Get-DiskHealth
    $perf    = Get-PerformanceSnapshot
    $events  = Get-EventLogSummary
    $update  = Get-UpdateStatus
    $netInfo = Get-NetworkInfoAndTests
    $services = $null
    $software = $null

    if (-not $Minimal) {
        $services = Get-RunningServices
        $software = Get-InstalledSoftware
    }

    $findings = Get-SecurityFindings -Security $sec -UpdateStatus $update -NetworkTests $netInfo.Tests

    $report = Generate-HTMLSnapshot -Specs $specs -Security $sec -Disks $disks `
        -PerfSummary $perf.Summary -Events $events -Services $services -Software $software `
        -NetworkTests $netInfo.Tests -Findings $findings -Minimal:$Minimal

    Write-Host "Snapshot report written to: $report"
    exit
}

# -----------------------------
# GUI mode (WPF)
# -----------------------------

# Ensure STA for WPF
if ([threading.thread]::CurrentThread.ApartmentState -ne 'STA') {
    Write-Verbose "Restarting PowerShell in STA mode..."
    $psi = @{
        FilePath     = (Get-Process -Id $PID).Path
        ArgumentList = "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`""
        WindowStyle  = "Normal"
    }
    Start-Process @psi
    exit
}

# XAML UI
$Xaml = @"
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="System Health Snapshot" Height="650" Width="1100"
        WindowStartupLocation="CenterScreen"
        FontFamily="Segoe UI" FontSize="12">
  <Grid Margin="10">
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto"/>
      <RowDefinition Height="*"/>
      <RowDefinition Height="Auto"/>
    </Grid.RowDefinitions>

    <!-- Top bar -->
    <StackPanel Orientation="Horizontal" Grid.Row="0" Margin="0,0,0,8">
      <TextBlock Text="Search current tab:" VerticalAlignment="Center" Margin="0,0,6,0"/>
      <TextBox x:Name="txtSearch" Width="220" Margin="0,0,10,0"
               ToolTip="Type to filter rows in the active tab." />
      <Button x:Name="btnRefreshAll" Content="Refresh All" Width="95" Margin="0,0,6,0"
              ToolTip="Reload all system data for every tab." />
      <Button x:Name="btnExport" Content="Export Tab" Width="95" Margin="0,0,6,0"
              ToolTip="Export the current tab's data to CSV." />
      <Button x:Name="btnSnapshot" Content="Snapshot Report" Width="120" Margin="0,0,6,0"
              ToolTip="Generate an HTML snapshot report and open it." />
      <Button x:Name="btnTechSummary" Content="Copy Tech Summary" Width="140"
              ToolTip="Copy a ticket-ready technician summary to clipboard." />
    </StackPanel>

    <!-- Tabs -->
    <TabControl x:Name="mainTabs" Grid.Row="1">
      <TabItem Header="Specs" ToolTip="Hardware and OS details for this computer.">
        <Grid Margin="0">
          <DataGrid x:Name="dgSpecs" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Disks" ToolTip="Physical disks and logical volumes with size and health.">
        <Grid Margin="0">
          <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
          </Grid.RowDefinitions>

          <StackPanel Orientation="Horizontal" Grid.Row="0" Margin="0,0,0,4">
            <CheckBox x:Name="cbLowDisk"
                      Content="Only low disk space (&lt; 15%)"
                      ToolTip="Show only logical volumes with free space below 15%."/>
            <TextBlock x:Name="lblDiskSummary"
                       Margin="16,0,0,0"
                       VerticalAlignment="Center"
                       FontSize="11"
                       Foreground="Gray"/>
            <Button x:Name="btnCopyDiskSummary"
                    Content="Copy summary"
                    Margin="8,0,0,0"
                    VerticalAlignment="Center"
                    FontSize="11"
                    Padding="6,2"
                    ToolTip="Copy disk summary text to clipboard."/>
          </StackPanel>

          <DataGrid x:Name="dgDisks" Grid.Row="1" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
                <Style.Triggers>
                  <DataTrigger Binding="{Binding RiskLevel}" Value="Critical">
                    <Setter Property="Background" Value="#FFFFE0E0" />
                  </DataTrigger>
                  <DataTrigger Binding="{Binding RiskLevel}" Value="Warning">
                    <Setter Property="Background" Value="#FFFFF8DC" />
                  </DataTrigger>
                </Style.Triggers>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Services" ToolTip="Windows services and their current status.">
        <Grid Margin="0">
          <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
          </Grid.RowDefinitions>

          <StackPanel Orientation="Horizontal" Grid.Row="0" Margin="0,0,0,4">
            <CheckBox x:Name="cbStoppedAuto"
                      Content="Only stopped automatic services"
                      ToolTip="Show only services that are Automatic and currently Stopped."/>

            <TextBlock Text="Status:"
                       Margin="16,0,4,0"
                       VerticalAlignment="Center"/>
            <ComboBox x:Name="cmbServiceStatus"
                      Width="90"
                      SelectedIndex="0">
              <ComboBoxItem Content="All" />
              <ComboBoxItem Content="Running" />
              <ComboBoxItem Content="Stopped" />
            </ComboBox>

            <TextBlock Text="Start type:"
                       Margin="8,0,4,0"
                       VerticalAlignment="Center"/>
            <ComboBox x:Name="cmbServiceStartType"
                      Width="100"
                      SelectedIndex="0">
              <ComboBoxItem Content="All" />
              <ComboBoxItem Content="Automatic" />
              <ComboBoxItem Content="Manual" />
              <ComboBoxItem Content="Disabled" />
            </ComboBox>

            <TextBlock x:Name="lblServiceSummary"
                       Margin="16,0,0,0"
                       VerticalAlignment="Center"
                       FontSize="11"
                       Foreground="Gray"/>

            <Button x:Name="btnCopyServiceSummary"
                    Content="Copy summary"
                    Margin="8,0,0,0"
                    VerticalAlignment="Center"
                    FontSize="11"
                    Padding="6,2"
                    ToolTip="Copy service summary text to clipboard."/>
          </StackPanel>

          <DataGrid x:Name="dgServices" Grid.Row="1" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
                <Style.Triggers>
                  <DataTrigger Binding="{Binding Problem}" Value="True">
                    <Setter Property="Background" Value="#FFFFF0E0" />
                  </DataTrigger>
                </Style.Triggers>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Software" ToolTip="Installed applications from common uninstall locations.">
        <Grid Margin="0">
          <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
          </Grid.RowDefinitions>

          <StackPanel Orientation="Horizontal" Grid.Row="0" Margin="0,0,0,4">
            <CheckBox x:Name="cbRecentSoftware"
                      Content="Only installed in last 30 days"
                      ToolTip="Show only software whose InstallDate is within the last 30 days."/>
            <TextBlock x:Name="lblSoftwareSummary"
                       Margin="16,0,0,0"
                       VerticalAlignment="Center"
                       FontSize="11"
                       Foreground="Gray"/>
            <Button x:Name="btnCopySoftwareSummary"
                    Content="Copy summary"
                    Margin="8,0,0,0"
                    VerticalAlignment="Center"
                    FontSize="11"
                    Padding="6,2"
                    ToolTip="Copy software summary text to clipboard."/>
          </StackPanel>

          <DataGrid x:Name="dgSoftware" Grid.Row="1" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Security" ToolTip="Defender, Firewall, BitLocker, and UAC status.">
        <Grid Margin="0">
          <DataGrid x:Name="dgSecurity" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Network" ToolTip="Network adapters and basic connectivity tests.">
        <Grid Margin="0">
          <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
          </Grid.RowDefinitions>

          <DataGrid x:Name="dgNetAdapters" Grid.Row="0" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0,0,0,4"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>

          <DataGrid x:Name="dgNetTests" Grid.Row="1" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0,4,0,0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column"
                    Height="110">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Performance" ToolTip="CPU and RAM usage snapshot.">
        <Grid Margin="0">
          <DataGrid x:Name="dgPerf" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Processes" ToolTip="Top processes by CPU.">
        <Grid Margin="0">
          <DataGrid x:Name="dgProcs" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Events" ToolTip="Event log summary for last 24 hours.">
        <Grid Margin="0">
          <DataGrid x:Name="dgEvents" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>

      <TabItem Header="Findings" ToolTip="Security findings and recommendations.">
        <Grid Margin="0">
          <DataGrid x:Name="dgFindings" AutoGenerateColumns="True" IsReadOnly="True"
                    CanUserAddRows="False" CanUserDeleteRows="False"
                    CanUserSortColumns="True"
                    Margin="0"
                    AlternationCount="2"
                    AlternatingRowBackground="#FFF5F5F5"
                    GridLinesVisibility="Horizontal"
                    HeadersVisibility="Column">
            <DataGrid.RowStyle>
              <Style TargetType="DataGridRow">
                <Setter Property="ToolTip">
                  <Setter.Value>
                    <TextBlock Text="{Binding}" TextWrapping="Wrap" />
                  </Setter.Value>
                </Setter>
              </Style>
            </DataGrid.RowStyle>
          </DataGrid>
        </Grid>
      </TabItem>
    </TabControl>

    <!-- Global loading overlay over all tabs -->
    <Border x:Name="loadingOverlay"
            Grid.Row="1"
            Background="#80000000"
            Visibility="Collapsed">
      <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center">
        <TextBlock Text="Loading system data..."
                   Foreground="White"
                   FontSize="16"
                   HorizontalAlignment="Center"
                   Margin="0,0,0,8"/>
        <ProgressBar IsIndeterminate="True"
                     Width="220"
                     Height="16"/>
      </StackPanel>
    </Border>

    <!-- Bottom status -->
    <DockPanel Grid.Row="2" Margin="0,8,0,0">
      <TextBlock x:Name="txtStatus"
                 DockPanel.Dock="Left"
                 Text="Ready"
                 FontSize="10"
                 HorizontalAlignment="Left"/>
      <TextBlock DockPanel.Dock="Right"
                 Text="Tip: Click column headers to sort. Right-click services for actions."
                 FontSize="10"
                 HorizontalAlignment="Right"/>
    </DockPanel>
  </Grid>
</Window>
"@


$reader = New-Object System.Xml.XmlNodeReader ([xml]$Xaml)
$window = [Windows.Markup.XamlReader]::Load($reader)

# Controls
$txtSearch       = $window.FindName('txtSearch')
$btnRefreshAll   = $window.FindName('btnRefreshAll')
$btnExport       = $window.FindName('btnExport')
$btnSnapshot     = $window.FindName('btnSnapshot')
$btnTechSummary  = $window.FindName('btnTechSummary')
$mainTabs        = $window.FindName('mainTabs')
$txtStatus       = $window.FindName('txtStatus')

$cbLowDisk        = $window.FindName('cbLowDisk')
$cbStoppedAuto    = $window.FindName('cbStoppedAuto')
$cbRecentSoftware = $window.FindName('cbRecentSoftware')
$cmbServiceStatus     = $window.FindName('cmbServiceStatus')
$cmbServiceStartType  = $window.FindName('cmbServiceStartType')
$loadingOverlay       = $window.FindName('loadingOverlay')

$lblDiskSummary     = $window.FindName('lblDiskSummary')
$lblServiceSummary  = $window.FindName('lblServiceSummary')
$lblSoftwareSummary = $window.FindName('lblSoftwareSummary')

$btnCopyDiskSummary     = $window.FindName('btnCopyDiskSummary')
$btnCopyServiceSummary  = $window.FindName('btnCopyServiceSummary')
$btnCopySoftwareSummary = $window.FindName('btnCopySoftwareSummary')

$dgSpecs       = $window.FindName('dgSpecs')
$dgDisks       = $window.FindName('dgDisks')
$dgServices    = $window.FindName('dgServices')
$dgSoftware    = $window.FindName('dgSoftware')
$dgSecurity    = $window.FindName('dgSecurity')
$dgNetAdapters = $window.FindName('dgNetAdapters')
$dgNetTests    = $window.FindName('dgNetTests')
$dgPerf        = $window.FindName('dgPerf')
$dgProcs       = $window.FindName('dgProcs')
$dgEvents      = $window.FindName('dgEvents')
$dgFindings    = $window.FindName('dgFindings')

Enable-GridSorting $dgSpecs
Enable-GridSorting $dgDisks
Enable-GridSorting $dgServices
Enable-GridSorting $dgSoftware
Enable-GridSorting $dgSecurity
Enable-GridSorting $dgNetAdapters
Enable-GridSorting $dgNetTests
Enable-GridSorting $dgPerf
Enable-GridSorting $dgProcs
Enable-GridSorting $dgEvents
Enable-GridSorting $dgFindings

# Context menus (copy row for all, plus service actions)

function Add-RowContextMenu {
    param(
        [System.Windows.Controls.DataGrid]$Grid,
        [switch]$ServiceActions
    )

    $menu = New-Object System.Windows.Controls.ContextMenu

    # Copy row
    $miCopy = New-Object System.Windows.Controls.MenuItem
    $miCopy.Header = "Copy row"
    $miCopy.Add_Click({
        param($sender,$eventArgs)
        $item = $Grid.SelectedItem
        if ($item) {
            # Turn the row into key: value pairs instead of just headers
            $props = $item.PSObject.Properties
            if ($props) {
                $lines = @()
                foreach ($p in $props) {
                    $lines += ("{0}: {1}" -f $p.Name, $p.Value)
                }
                $text = $lines -join "`r`n"
            }
            else {
                $text = ($item | Out-String)
            }

            [System.Windows.Clipboard]::SetText($text)
            $txtStatus.Text = "Row copied to clipboard."
        }
    })

    $menu.Items.Add($miCopy) | Out-Null

    if ($ServiceActions) {
        $menu.Items.Add((New-Object System.Windows.Controls.Separator)) | Out-Null

        foreach ($op in 'Start','Stop','Restart') {
            $mi = New-Object System.Windows.Controls.MenuItem
            $mi.Header = $op

            # Avoid closure bug: use sender.Header
            $mi.Add_Click({
                param($sender,$eventArgs)

                if (-not (Test-IsAdmin)) {
                    [System.Windows.MessageBox]::Show(
                        "You must run this tool as Administrator to manage services.",
                        "Service action",
                        'OK','Warning'
                    ) | Out-Null
                    return
                }

                $svc = $Grid.SelectedItem
                if (-not ($svc -and $svc.Name)) { return }

                $action = $sender.Header  # "Start", "Stop", or "Restart"

                try {
                    switch ($action) {
                        'Start'   { Start-Service   -Name $svc.Name -ErrorAction Stop }
                        'Stop'    { Stop-Service    -Name $svc.Name -ErrorAction Stop }
                        'Restart' { Restart-Service -Name $svc.Name -ErrorAction Stop }
                    }

                    # Reload so the grid reflects the new state
                    Load-AllData
                    Refresh-CurrentTab

                    [System.Windows.MessageBox]::Show(
                        ("{0} service '{1}' succeeded." -f $action, $svc.Name),
                        "Service action",
                        'OK','Information'
                    ) | Out-Null
                }
                catch {
                    [System.Windows.MessageBox]::Show(
                        ("{0} service '{1}' failed:`n{2}" -f $action, $svc.Name, $_),
                        "Service action error",
                        'OK','Error'
                    ) | Out-Null
                }
            })

            $menu.Items.Add($mi) | Out-Null
        }
    }

    $Grid.ContextMenu = $menu
}

Add-RowContextMenu -Grid $dgSpecs
Add-RowContextMenu -Grid $dgDisks
Add-RowContextMenu -Grid $dgServices -ServiceActions
Add-RowContextMenu -Grid $dgSoftware
Add-RowContextMenu -Grid $dgSecurity
Add-RowContextMenu -Grid $dgNetAdapters
Add-RowContextMenu -Grid $dgNetTests
Add-RowContextMenu -Grid $dgPerf
Add-RowContextMenu -Grid $dgProcs
Add-RowContextMenu -Grid $dgEvents
Add-RowContextMenu -Grid $dgFindings

# Data storage
$script:dataSets = @{
    Specs          = @()
    Disks          = @()
    Services       = @()
    Software       = @()
    Security       = @()
    Performance    = @()
    Processes      = @()
    Events         = @()
    NetAdapters    = @()
    NetTests       = @()
    Findings       = @()
}

# Raw objects for tech summary
$script:rawSpecs        = $null
$script:rawSecurity     = $null
$script:rawDisks        = $null
$script:rawServices     = $null
$script:rawSoftware     = $null
$script:rawPerfSummary  = $null
$script:rawUpdateStatus = $null
$script:rawNetTests     = $null

$script:tabMap = @{
    "Specs"       = @{ Key="Specs";       Grid=$dgSpecs }
    "Disks"       = @{ Key="Disks";       Grid=$dgDisks }
    "Services"    = @{ Key="Services";    Grid=$dgServices }
    "Software"    = @{ Key="Software";    Grid=$dgSoftware }
    "Security"    = @{ Key="Security";    Grid=$dgSecurity }
    "Network"     = @{ Key="NetAdapters"; Grid=$dgNetAdapters }
    "Performance" = @{ Key="Performance"; Grid=$dgPerf }
    "Processes"   = @{ Key="Processes";   Grid=$dgProcs }
    "Events"      = @{ Key="Events";      Grid=$dgEvents }
    "Findings"    = @{ Key="Findings";    Grid=$dgFindings }
}

function Load-AllData {
    Write-Verbose "Loading data..."

    $spec      = Get-SystemSpecs
    $sec       = Get-SecurityStatus
    $disks     = Get-DiskHealth
    $services  = Get-RunningServices
    $software  = Get-InstalledSoftware
    $perf      = Get-PerformanceSnapshot
    $events    = Get-EventLogSummary
    $update    = Get-UpdateStatus
    $netInfo   = Get-NetworkInfoAndTests

    $findings  = Get-SecurityFindings -Security $sec -UpdateStatus $update -NetworkTests $netInfo.Tests

    # Store raw for tech summary
    $script:rawSpecs        = $spec
    $script:rawSecurity     = $sec
    $script:rawDisks        = $disks
    $script:rawServices     = $services
    $script:rawSoftware     = $software
    $script:rawPerfSummary  = $perf.Summary
    $script:rawUpdateStatus = $update
    $script:rawNetTests     = $netInfo.Tests

    # Grid datasets
    $script:dataSets.Specs       = @(ConvertTo-NameValueTable -Object $spec)
    $script:dataSets.Security    = @(ConvertTo-NameValueTable -Object $sec)
    $script:dataSets.Disks       = @($disks)
    $script:dataSets.Services    = @($services)
    $script:dataSets.Software    = @($software)
    $script:dataSets.Performance = @(ConvertTo-NameValueTable -Object $perf.Summary)
    $script:dataSets.Processes   = @($perf.TopProcesses)
    $script:dataSets.Events      = @($events)
    $script:dataSets.NetAdapters = @($netInfo.Adapters)
    $script:dataSets.NetTests    = @($netInfo.Tests)
    $script:dataSets.Findings    = @($findings)

    # Bind
    $dgSpecs.ItemsSource       = $script:dataSets.Specs
    $dgSecurity.ItemsSource    = $script:dataSets.Security
    $dgDisks.ItemsSource       = $script:dataSets.Disks
    $dgServices.ItemsSource    = $script:dataSets.Services
    $dgSoftware.ItemsSource    = $script:dataSets.Software
    $dgPerf.ItemsSource        = $script:dataSets.Performance
    $dgProcs.ItemsSource       = $script:dataSets.Processes
    $dgEvents.ItemsSource      = $script:dataSets.Events
    $dgNetAdapters.ItemsSource = $script:dataSets.NetAdapters
    $dgNetTests.ItemsSource    = $script:dataSets.NetTests
    $dgFindings.ItemsSource    = $script:dataSets.Findings

    Update-DiskSummary
    Update-ServiceSummary
    Update-SoftwareSummary
}

function Update-Status {
    param(
        [string]$Header,
        [System.Collections.IEnumerable]$Data
    )
    $count = @($Data).Count
    if ($count -eq 0) {
        $txtStatus.Text = "${Header}: no data (pending action or not applicable)"
    }
    else {
        $txtStatus.Text = "${Header}: ${count} row(s)"
    }
}

function Update-DiskSummary {
    if (-not $lblDiskSummary) { return }

    $all = $script:dataSets.Disks
    if (-not $all) {
        $lblDiskSummary.Text = ""
        return
    }

    $stats = Get-DiskSummaryStats -Disks $all
    $lblDiskSummary.Text = "Logical volumes: ${($stats.LogicalVolumes)} | Critical <10%: ${($stats.CriticalBelow10Percent)} | Warning <20%: ${($stats.WarningBelow20Percent)}"
}

function Update-ServiceSummary {
    if (-not $lblServiceSummary) { return }

    $all = $script:dataSets.Services
    if (-not $all) {
        $lblServiceSummary.Text = ""
        return
    }

    $stats = Get-ServiceSummaryStats -Services $all
    $lblServiceSummary.Text = "Total: ${($stats.TotalServices)} | Running: ${($stats.Running)} | Stopped auto: ${($stats.StoppedAutomatic)}"
}

function Update-SoftwareSummary {
    if (-not $lblSoftwareSummary) { return }

    $all = $script:dataSets.Software
    if (-not $all) {
        $lblSoftwareSummary.Text = ""
        return
    }

    $stats = Get-SoftwareSummaryStats -Software $all
    $lblSoftwareSummary.Text = "Total: ${($stats.TotalInstalled)} | Installed in last 30 days: ${($stats.InstalledLast30Days)}"
}

function Apply-ProblemFilters {
    param(
        [string]$Header,
        [System.Collections.IEnumerable]$Data
    )

    $out = @($Data)

    switch ($Header) {
        'Disks' {
            if ($cbLowDisk -and $cbLowDisk.IsChecked -eq $true) {
                $out = @($out | Where-Object { $_.Free_Percent -ne $null -and $_.Free_Percent -lt 15 })
            }
        }

        'Services' {
            # Status filter (Running / Stopped / All)
            if ($cmbServiceStatus) {
                $selItem = $cmbServiceStatus.SelectedItem
                if ($selItem -and $selItem.Content) {
                    $sel = $selItem.Content.ToString()
                    switch ($sel) {
                        'Running' { $out = @($out | Where-Object { $_.Status -eq 'Running' }) }
                        'Stopped' { $out = @($out | Where-Object { $_.Status -eq 'Stopped' }) }
                    }
                }
            }

            # StartType filter (Automatic / Manual / Disabled / All)
            if ($cmbServiceStartType) {
                $selItem2 = $cmbServiceStartType.SelectedItem
                if ($selItem2 -and $selItem2.Content) {
                    $sel2 = $selItem2.Content.ToString()
                    switch ($sel2) {
                        'Automatic' { $out = @($out | Where-Object { $_.StartType -eq 'Automatic' }) }
                        'Manual'    { $out = @($out | Where-Object { $_.StartType -eq 'Manual' }) }
                        'Disabled'  { $out = @($out | Where-Object { $_.StartType -eq 'Disabled' }) }
                    }
                }
            }

            # Existing only broken autos checkbox
            if ($cbStoppedAuto -and $cbStoppedAuto.IsChecked -eq $true) {
                $out = @($out | Where-Object { $_.Problem -eq $true })
            }
        }

        'Software' {
            if ($cbRecentSoftware -and $cbRecentSoftware.IsChecked -eq $true) {
                $cut = (Get-Date).AddDays(-30)
                $out = @($out | Where-Object { $_.InstallDate -and $_.InstallDate -ge $cut })
            }
        }
    }

    return ,$out
}

function Refresh-CurrentTab {
    $currentTab = $mainTabs.SelectedItem
    if (-not $currentTab) { return }

    $header = $currentTab.Header.ToString()
    if (-not $script:tabMap.ContainsKey($header)) { return }

    $tabInfo = $script:tabMap[$header]
    $key     = $tabInfo.Key
    $grid    = $tabInfo.Grid

    $allData = $script:dataSets[$key]
    if (-not $allData) {
        $grid.ItemsSource = $null
        Update-Status -Header $header -Data @()
        return
    }

    $dataToShow = @($allData)

    $search = $txtSearch.Text
    if (-not [string]::IsNullOrWhiteSpace($search)) {
        $pattern = [regex]::Escape($search)
        $dataToShow = @(
            $dataToShow | Where-Object {
                ($_ | Out-String) -match $pattern
            }
        )
    }

    $dataToShow = Apply-ProblemFilters -Header $header -Data $dataToShow

    $grid.ItemsSource = $dataToShow
    Update-Status -Header $header -Data $dataToShow
}

function Export-CurrentTab {
    $currentTab = $mainTabs.SelectedItem
    if (-not $currentTab) { return }

    $header = $currentTab.Header.ToString()
    if (-not $script:tabMap.ContainsKey($header)) { return }

    $tabInfo = $script:tabMap[$header]
    $grid    = $tabInfo.Grid

    $data = @($grid.ItemsSource)
    if (-not $data -or $data.Count -eq 0) {
        [System.Windows.MessageBox]::Show(
            "No data to export in the '${header}' tab.",
            "Export",
            'OK','Information'
        ) | Out-Null
        return
    }

    $dlg = New-Object Microsoft.Win32.SaveFileDialog
    $dlg.Filter = "CSV files (*.csv)|*.csv|All files (*.*)|*.*"
    $dlg.FileName = ("{0}-{1}-{2}.csv" -f $header, $env:COMPUTERNAME, (Get-Date -Format 'yyyyMMdd_HHmmss'))

    if ($dlg.ShowDialog() -eq $true) {
        try {
            $data | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $dlg.FileName
            [System.Windows.MessageBox]::Show(
                ("Exported {0} row(s) to:`n{1}" -f $data.Count, $dlg.FileName),
                "Export complete",
                'OK','Information'
            ) | Out-Null
        }
        catch {
            [System.Windows.MessageBox]::Show(
                "Failed to export: $_",
                "Export error",
                'OK','Error'
            ) | Out-Null
        }
    }
}

function Generate-AndOpenSnapshot {
    $spec     = Get-SystemSpecs
    $sec      = Get-SecurityStatus
    $disks    = Get-DiskHealth
    $perf     = Get-PerformanceSnapshot
    $events   = Get-EventLogSummary
    $update   = Get-UpdateStatus
    $netInfo  = Get-NetworkInfoAndTests
    $services = Get-RunningServices
    $software = Get-InstalledSoftware
    $findings = Get-SecurityFindings -Security $sec -UpdateStatus $update -NetworkTests $netInfo.Tests

    $path = Generate-HTMLSnapshot -Specs $spec -Security $sec -Disks $disks `
        -PerfSummary $perf.Summary -Events $events -Services $services -Software $software `
        -NetworkTests $netInfo.Tests -Findings $findings

    [System.Diagnostics.Process]::Start($path) | Out-Null
}

function Copy-TechSummary {
    $diskStats    = if ($script:rawDisks)    { Get-DiskSummaryStats    -Disks $script:rawDisks }    else { $null }
    $serviceStats = if ($script:rawServices) { Get-ServiceSummaryStats -Services $script:rawServices } else { $null }
    $softwareStats= if ($script:rawSoftware) { Get-SoftwareSummaryStats -Software $script:rawSoftware } else { $null }

    $text = Get-TechnicianSummary -Specs $script:rawSpecs `
        -DiskStats $diskStats -ServiceStats $serviceStats -SoftwareStats $softwareStats `
        -Security $script:rawSecurity -UpdateStatus $script:rawUpdateStatus -NetworkTests $script:rawNetTests

    if ($text) {
        [System.Windows.Clipboard]::SetText($text)
        $txtStatus.Text = "Technician summary copied to clipboard."
    }
}

# Event wiring
$btnRefreshAll.Add_Click({
    Load-AllData
    Refresh-CurrentTab
})

$btnExport.Add_Click({
    Export-CurrentTab
})

$btnSnapshot.Add_Click({
    Generate-AndOpenSnapshot
})

$btnTechSummary.Add_Click({
    Copy-TechSummary
})

$txtSearch.Add_TextChanged({
    Refresh-CurrentTab
})

if ($cbLowDisk) {
    $cbLowDisk.Add_Click({ Refresh-CurrentTab })
}
if ($cbStoppedAuto) {
    $cbStoppedAuto.Add_Click({ Refresh-CurrentTab })
}
if ($cmbServiceStatus) {
    $cmbServiceStatus.Add_SelectionChanged({ Refresh-CurrentTab })
}
if ($cmbServiceStartType) {
    $cmbServiceStartType.Add_SelectionChanged({ Refresh-CurrentTab })
}

if ($cbRecentSoftware) {
    $cbRecentSoftware.Add_Click({ Refresh-CurrentTab })
}

if ($btnCopyDiskSummary) {
    $btnCopyDiskSummary.Add_Click({
        if ($lblDiskSummary.Text) {
            [System.Windows.Clipboard]::SetText($lblDiskSummary.Text)
            $txtStatus.Text = "Disk summary copied to clipboard."
        }
    })
}
if ($btnCopyServiceSummary) {
    $btnCopyServiceSummary.Add_Click({
        if ($lblServiceSummary.Text) {
            [System.Windows.Clipboard]::SetText($lblServiceSummary.Text)
            $txtStatus.Text = "Service summary copied to clipboard."
        }
    })
}
if ($btnCopySoftwareSummary) {
    $btnCopySoftwareSummary.Add_Click({
        if ($lblSoftwareSummary.Text) {
            [System.Windows.Clipboard]::SetText($lblSoftwareSummary.Text)
            $txtStatus.Text = "Software summary copied to clipboard."
        }
    })
}

$mainTabs.Add_SelectionChanged({
    Refresh-CurrentTab
})

# On first render, show loading overlay then populate data
$window.Add_ContentRendered({
    if ($loadingOverlay) {
        $loadingOverlay.Visibility = 'Visible'
    }
    $txtStatus.Text = "Loading system data..."

    $null = $window.Dispatcher.BeginInvoke(
        [System.Action]{
            try {
                Load-AllData
                Refresh-CurrentTab
                $txtStatus.Text = "Ready"
            }
            finally {
                if ($loadingOverlay) {
                    $loadingOverlay.Visibility = 'Collapsed'
                }
            }
        },
        [System.Windows.Threading.DispatcherPriority]::Background
    )
})

# Show window
$null = $window.ShowDialog()
